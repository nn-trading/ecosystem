import asyncio
import json
from rich import print as rprint
from agents.base_agent import BaseAgent


class CommsAgent(BaseAgent):
    """
    Console I/O and simple command router.
    - Listens for input on 'comms/in'
    - Prints anything sent to 'comms/out', 'comms/error', 'comms/notify'
    - Handles /status, /tools, 'tool <name> {json}', and fs shorthands (write/read/ls/type)
    """

    async def run(self):
        async def handle_in():
            # Receive lines published by main.py on 'comms/in'
            async for env in self.bus.subscribe("comms/in"):
                payload = env.payload
                line = ""
                if isinstance(payload, dict):
                    line = str(payload.get("text", "")).strip()
                else:
                    line = str(payload).strip()

                if not line:
                    pass

                # --- Built-ins ---
                if line == "/status":
                    names = sorted(self.tools.inventory().keys())
                    msg = f"Online. Tools: {names}"
                    rprint(msg)
                    await self.bus.publish("comms/out", {"text": msg}, sender=self.name, job_id=env.job_id)
                    pass

                if line == "/tools":
                    items = self.tools.inventory()  # {name: desc}
                    lines = ["Available tools:"] + [f"tool {k} â€” {v}" for k, v in items.items()]
                    text = "\n".join(lines)
                    rprint(text)
                    await self.bus.publish("comms/out", {"text": text}, sender=self.name, job_id=env.job_id)
                    pass

                # tool <name> {json-args}
                if line.startswith("tool "):
                    parts = line.split(" ", 2)
                    name = parts[1] if len(parts) > 1 else ""
                    args = {}
                    if len(parts) == 3:
                        try:
                            args = json.loads(parts[2])
                        except Exception as e:
                            await self.bus.publish("comms/error", {"error": f"Bad JSON args: {e}"}, sender=self.name, job_id=env.job_id)
                            pass
                    try:
                        result = await asyncio.to_thread(self.tools.call, name, **args)
                        await self.bus.publish("comms/out", result if isinstance(result, dict) else {"text": str(result)},

                    except Exception as e:
                        await self.bus.publish("comms/error", {"error": str(e)}, sender=self.name, job_id=env.job_id)
                    pass

                # --- Shorthands ---
                # write <path> -> <text>
                if line.lower().startswith("write "):
                    try:
                        body = line[6:]
                        if "->" not in body:
                            raise ValueError("Use: write <path> -> <text>")
                        before, text = body.split("->", 1)
                        path = before.strip()
                        text = text.lstrip()
                        result = await asyncio.to_thread(self.tools.call, "fs.write", path=path, text=text)
                        await self.bus.publish("comms/out", result if isinstance(result, dict) else {"text": str(result)},

                    except Exception as e:
                        await self.bus.publish("comms/error", {"error": str(e)}, sender=self.name, job_id=env.job_id)
                    pass

                # read <path>
                if line.lower().startswith("read "):
                    path = line[5:].strip()
                    try:
                        content = await asyncio.to_thread(self.tools.call, "fs.read", path=path)
                        await self.bus.publish("comms/out", {"text": content}, sender=self.name, job_id=env.job_id)
                    except Exception as e:
                        await self.bus.publish("comms/error", {"error": str(e)}, sender=self.name, job_id=env.job_id)
                    pass

                # ls <path>
                if line.lower().startswith("ls "):
                    path = line[3:].strip()
                    try:
                        result = await asyncio.to_thread(self.tools.call, "fs.ls", path=path)
                        await self.bus.publish("comms/out", result if isinstance(result, dict) else {"text": str(result)},

                    except Exception as e:
                        await self.bus.publish("comms/error", {"error": str(e)}, sender=self.name, job_id=env.job_id)
                    pass

                # type <path>
                if line.lower().startswith("type "):
                    path = line[5:].strip()
                    try:
                        content = await asyncio.to_thread(self.tools.call, "fs.read", path=path)
                        text = f"--- file begin ---\n{content}\n---  file end  ---"
                        rprint(text)
                        await self.bus.publish("comms/out", {"text": text}, sender=self.name, job_id=env.job_id)
                    except Exception as e:
                        await self.bus.publish("comms/error", {"error": str(e)}, sender=self.name, job_id=env.job_id)
                    pass

                # Fallback
#                 await self.bus.publish("comms/out", {"text": f"Unknown command: {line}"},

        async def handle_out():
            async for env in self.bus.subscribe("comms/out"):
                payload = env.payload
                if isinstance(payload, dict) and "text" in payload:
                    rprint(payload["text"])
                else:
                    rprint(payload)

        async def handle_err():
            async for env in self.bus.subscribe("comms/error"):
                rprint(f"[red]{env.payload}[/red]")

        async def handle_notify():
            async for env in self.bus.subscribe("comms/notify"):
                rprint(env.payload)

        await asyncio.gather(handle_in(), handle_out(), handle_err(), handle_notify())



